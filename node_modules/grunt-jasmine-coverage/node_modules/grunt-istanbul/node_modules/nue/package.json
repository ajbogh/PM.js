{
  "name": "nue",
  "description": "An async control-flow library suited for node.js.",
  "keywords": [
    "control-flow",
    "async"
  ],
  "author": {
    "name": "Toshihiro Nakamura",
    "email": "toshihiro.nakamura@gmail.com"
  },
  "contributors": [],
  "repository": {
    "type": "git",
    "url": "git://github.com/nakamura-to/nue.git"
  },
  "main": "./lib/nue.js",
  "devDependencies": {
    "mocha": "~0.11.0"
  },
  "version": "0.7.0-dev",
  "readme": "nue â€” An async control-flow library\r\n===================================\r\n\r\nnue is an async control-flow library suited for node.js.\r\n\r\n## Installing\r\n\r\n```\r\n$ npm install nue\r\n```\r\n\r\n## Example\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('nue').as;\r\nvar fs = require('fs');\r\n\r\nvar myFlow = flow('myFlow')(\r\n  function readFiles(file1, file2) {\r\n    fs.readFile(file1, 'utf8', this.async(as(1)));\r\n    fs.readFile(file2, 'utf8', this.async(as(1)));\r\n  },\r\n  function concat(data1, data2) {\r\n    this.next(data1 + data2);\r\n  },\r\n  function end(data) {\r\n    if (this.err) throw this.err;\r\n    console.log(data);\r\n    console.log('done');\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow('file1', 'file2');\r\n```\r\n\r\n## API\r\n\r\n### Top Level API\r\n\r\nThe `nue` module provides following API.\r\n\r\n#### flow([Function steps...]) -> Function\r\n\r\nReturn a function which represents the control-flow.\r\n\r\n* `steps`: Optional. Optional functions to execute in series.\r\n\r\n#### flow(String flowName) -> Function\r\n\r\nAccept a flow name and return another `flow` function.\r\n\r\n* `flowName`: Required. A flow name to be used for debug.\r\n\r\n#### parallel([Function steps...]) -> Function\r\n\r\nReturn a function which represents the parallel control-flow.\r\nThe `parallel` must be nested inside a `flow` or another `parallel`.\r\n\r\n* `steps`: Optional. Optional functions to execute in parallel.\r\n\r\n#### parallel(String flowName) -> Function\r\n\r\nAccept a flow name and return another `parallel` function.\r\n\r\n* `flowName`: Required. A flow name to be used for debug.\r\n\r\n#### as(Number index) -> Object\r\n\r\n* `index`: Required. An index to map an asynchronous callback argument to a next step argument.\r\nIf the index is zero, an error handling is skipped.\r\n\r\n\r\n### Step Context API\r\n\r\n`flow` and `parallel` API accept functions called `step`s. Each step context object - it means a `this` object in the step function - provides following API.\r\n\r\n#### next([Object values...]) -> Void\r\n\r\nA function to execute a next step immediately.  \r\n\r\n* `values`: Optional. Arguments for a next step.\r\n\r\n#### async([Object mapping]) -> Function\r\n\r\nA function to accept an argument mapping definition for a next step and return a callback. \r\n`async` can be called many times, but all calls are done in same tick. \r\nAnd all callbacks `async` returns must be called.\r\n\r\n* `mapping`: Optional. An argument mapping definition.\r\n \r\nTo map single argument, call `as` API and pass its result.  \r\n\r\n```js\r\nfs.readFile('file1', 'utf8', this.async(as(1)));\r\n```\r\n\r\nTo map multiple arguments, pass an object. \r\n\r\n```js\r\nchild_process.exec('whoami', this.async({stdout: as(1), stderr: as(2)}));\r\n```\r\n\r\nTo map multiple arguments except first one, pass no object. You can get result arguments by index.\r\n\r\n```js\r\nchild_process.exec('whoami', this.async());\r\n```\r\n\r\n#### asyncEach(Array array, Function callback(element, group, index, traversedArray)) -> Void\r\n\r\nA function to execute a provided function once per array element asynchronously. \r\n\r\n* `array`: Required. An array.\r\n* `callback`: Required. A function being executed once per array element. \r\nThe context object in the callback is same with outer step context object.\r\n* `element`: Required. A current element.\r\n* `group`: Required. Provedes `async` function to accept an argument mapping definition and return a callback.\r\n* `index`: Required. An element index.\r\n* `traversedArray`: Required. An array object being traversed.\r\n\r\n#### asyncEach(Number concurrency) -> Function\r\n\r\nA function to accept a concurrency number and return another `asyncEach` function which \r\nexecutes a provided function once per array element asynchronously with the specified cuncurrency. \r\nIf you use another `asyncEach` function directly, default concurrency 10 is used.\r\n\r\n* `concurrency`: Required. the number of concurrency.\r\n\r\n#### exec(Function function, [Object args...], Function callback(err, [values...])) -> Void\r\n\r\nA function to execute a specified `function` with `args` asynchronously. \r\n\r\n* `function`: Required. A function to be executed asynchronously.\r\n* `args`: Optional. Arguments for the `function`.\r\n* `callback`: Required. A function to be executed when the `function` is completed.\r\n* `err`: Required. An error in an async call.\r\n* `values`: Required. Results from the `function`.\r\n\r\n#### end([Object values...]) -> Void\r\n\r\nA function to execute a last step immediately to end a control-flow.\r\n\r\n* `values`: Optional. Arguments for a last step.\r\n\r\n#### endWith(Error err) -> Void\r\n\r\nA function to execute a last step immediately with an error to end a control-flow. \r\n\r\n* `err`: Required. An error object. This object can be referred as `this.err` in a last step.\r\n\r\n#### data : Object\r\n\r\nA object to share arbitrary data between steps in a control-flow.\r\n\r\n#### flowName : String\r\n\r\nA flow name.\r\n\r\n#### stepName : String\r\n\r\nA step name.\r\n\r\n#### err : Object\r\n\r\nAn error object, which is thrown with `throw`, passed to `this.endWith` or passed to an async callback as first argument.\r\nThis property is accessible in only last steps.\r\n\r\n## More Examples\r\n\r\n### Arguments Passing Between Functions\r\n\r\nArguments are passed with `this.next` or `this.async`.\r\n\r\n#### Synchronously\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\n\r\nvar myFlow = flow('myFlow')(\r\n  function concat(s1, s2) {\r\n    var length = s1.length + s2.length\r\n    this.next(s1, s2, length);\r\n  },\r\n  function end(s1, s2, length) {\r\n    if (this.err) throw this.err;\r\n    console.log(s1 + '.length + ' + s2 + '.length -> ' + length); // file1.length + file2.length -> 10\r\n    console.log('done');\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow('file1', 'file2');\r\n```\r\n\r\n#### Asynchronously\r\n\r\nTo pass asynchronous call results to a next function, arguments mapping definition is necessary.\r\nThe function `as` accepts an index to specify a callback argument and returns arguments mapping definition.\r\nThe function `this.async` accepts the mapping definition and return a callback.\r\nWhen all callbacks are completed, the next function is called with specific arguments.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('as').as;\r\nvar fs = require('fs');\r\n\r\nvar myFlow = flow('myFlow')(\r\n  function readFiles(file1, file2) {\r\n    fs.readFile(file1, 'utf8', this.async(as(1)));\r\n    fs.readFile(file2, 'utf8', this.async(as(1)));\r\n  },\r\n  function end(data1, data2) {\r\n    if (this.err) throw this.err;\r\n    console.log(data1 + data2); // FILE1FILE2\r\n    console.log('done');\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow('file1', 'file2');\r\n```\r\n\r\nArguments mapping definition can contain arbitrary values.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('as').as;\r\nvar fs = require('fs');\r\n\r\nvar myFlow = flow('myFlow')(\r\n  function readFiles(file1, file2) {\r\n    fs.readFile(file1, 'utf8', this.async({name: file1, data: as(1)}));\r\n    fs.readFile(file2, 'utf8', this.async({name: file2, data: as(1)}));\r\n  },\r\n  function end(f1, f2) {\r\n    if (this.err) throw this.err;\r\n    console.log(f1.name + ' and ' + f2.name + ' have been read.'); // file1 and file2 have been read.\r\n    console.log(f1.data + f2.data); // FILE1FILE2\r\n    console.log('done');\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow('file1', 'file2');\r\n```\r\n\r\n### Asynchronous Loop\r\n\r\n`this.asyncEach` executes a provided function once per array element asynchronously.\r\nBy default, the number of concurrency is 10.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('as').as;\r\nvar fs = require('fs');\r\n\r\nvar myFlow = flow('myFlow')(\r\n  function readFiles(files) {\r\n    this.asyncEach(files, function (file, group) {\r\n      fs.readFile(file, 'utf8', group.async({name: file, data: as(1)}));\r\n    });\r\n  },\r\n  function end(files) {\r\n    if (this.err) throw this.err;\r\n    var names = files.map(function (f) { return f.name; });\r\n    var contents = files.map(function (f) { return f.data});\r\n    console.log(names.join(' and ') + ' have been read.'); // file1 and file2 have been read.\r\n    console.log(contents.join('')); // FILE1FILE2\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow(['file1', 'file2']);\r\n```\r\n\r\nTo change the number of concurrency, specify the number as below.\r\n\r\n```js\r\n  function readFiles(files) {\r\n    this.asyncEach(5)(files, function (file, group) {\r\n       ...\r\n    });\r\n  },\r\n```\r\n\r\n### Flow Nesting\r\n\r\nA flow is composable. So it can be nested.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('as').as;\r\nvar fs = require('fs');\r\n\r\nvar subFlow = flow('subFlow')(\r\n  function readFile(file) {\r\n    fs.readFile(file, 'utf8', this.async(as(1)));\r\n  }\r\n);\r\n\r\nvar mainFlow = flow('mainFlow')(\r\n  function start() {\r\n    this.next('file1');\r\n  },\r\n  subFlow,\r\n  function end(result) {\r\n    if (this.err) throw this.err;\r\n    console.log(result);\r\n    console.log('done');\r\n    this.next();\r\n  }\r\n);\r\n\r\nmainFlow();\r\n```\r\n\r\n### Asynchronous Flow Execution\r\n\r\nA flow can be executed asynchronously.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('as').as;\r\nvar fs = require('fs');\r\n\r\nvar subFlow = flow('subFlow')(\r\n  function readFile(file) {\r\n    fs.readFile(file, 'utf8', this.async(as(1)));\r\n  }\r\n);\r\n\r\nvar mainFlow = flow('mainFlow')(\r\n  function start() {\r\n    this.exec(subFlow, 'file1', this.async(as(1)));\r\n    this.exec(subFlow, 'file2', this.async(as(1)));\r\n  },\r\n  function end(data1, data2) {\r\n    if (this.err) throw this.err;\r\n    console.log(data1 + data2);\r\n    console.log('done');\r\n    this.next();\r\n  }\r\n);\r\n\r\nmainFlow();\r\n```\r\n\r\n### Parallel Flow\r\n\r\nIn following example, the flow `par1-1` and `par1-2` are executed in parallel.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar parallel = require('nue').parallel;\r\n\r\nvar myFlow = flow('main')(\r\n  function one() {\r\n    console.log(this.stepName);\r\n    this.next(); \r\n  },\r\n  function two() {\r\n    console.log(this.stepName);\r\n    this.next(); \r\n  },\r\n  parallel('par1')(\r\n    flow('par1-1')(\r\n      function three() {\r\n        console.log(this.stepName);\r\n        this.next(); \r\n      },\r\n      function four() {\r\n        console.log(this.stepName);\r\n        this.next(); \r\n      }\r\n    ),\r\n    flow('par1-2')(\r\n      function five() {\r\n        console.log(this.stepName);\r\n        this.next(); \r\n      },\r\n      function six() {\r\n        console.log(this.stepName);\r\n        this.next(); \r\n      }\r\n    )\r\n  ),\r\n  function seven() {\r\n    console.log(this.stepName);\r\n    this.next(); \r\n  },\r\n  function eight() {\r\n    console.log(this.stepName);\r\n    this.next(); \r\n  },\r\n  function allDone() {\r\n    if (this.err) throw this.err;\r\n    console.log(this.stepName);\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow();\r\n```\r\n\r\nArguments to a parallel flow are passed to every forked functions.\r\nParallel flow results are passed to a next funtion as an array.\r\nThe array contains the results of forked functions.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar parallel = require('nue').parallel;\r\n\r\nvar myFlow = flow('main')(\r\n  function start() { \r\n    this.next(10, 20); \r\n  },\r\n  parallel('parallel')(\r\n    function add(x, y) { \r\n      this.next(x + y); \r\n    },\r\n    function sub(x, y) { \r\n      this.next(x - y);\r\n    }\r\n  ),\r\n  function end(results) {\r\n    if (this.err) throw this.err;\r\n    console.log('add result: ' + results[0]); // add result: 30 \r\n    console.log('sub result: ' + results[1]); // sub result: -10\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow();\r\n```\r\n\r\n### Data Sharing Between Functions\r\n\r\nEach step in a flow can share data through `this.data`.\r\n`this.data` is shared in a same flow.\r\nA nesting flow and any nested flows can't share `this.data`.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('as').as;\r\nvar fs = require('fs');\r\n\r\nvar myFlow = flow('myFlow')(\r\n  function readFiles(file1, file2) {\r\n    this.data.file1 = file1;\r\n    this.data.file2 = file2;\r\n    fs.readFile(file1, 'utf8', this.async(as(1)));\r\n    fs.readFile(file2, 'utf8', this.async(as(1)));\r\n  },\r\n  function concat(data1, data2) {\r\n    this.next(data1 + data2);\r\n  },\r\n  function end(data) {\r\n    if (this.err) throw this.err;\r\n    console.log(data);\r\n    console.log(this.data.file1 + ' and ' + this.data.file2 + ' are concatenated.');\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow('file1', 'file2');\r\n```\r\n\r\n### Error Handling\r\n\r\nIn a last step in a flow, `this.err` represents an error which is thrown with `throw`, passed to `this.endWith` or passed to an async callback as first argument. \r\nTo indicate error handling is completed, you must assign `null` to `this.err`.\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('as').as;\r\nvar fs = require('fs');\r\n\r\nvar myFlow = flow('myFlow')(\r\n  function readFiles(file1, file2) {\r\n    fs.readFile(file1, 'utf8', this.async(as(1)));\r\n    fs.readFile(file2, 'utf8', this.async(as(1)));\r\n  },\r\n  function concat(data1, data2) {\r\n    this.next(data1 + data2);\r\n  },\r\n  function end(data) {\r\n    if (this.err) {\r\n      // handle error\r\n      console.log(this.err.message);\r\n      // indicate error handling completion\r\n      this.err = null;\r\n    } else {\r\n      console.log(data);\r\n    }\r\n    console.log('done');\r\n    this.next();\r\n  }\r\n);\r\n\r\nmyFlow('file1', 'non-existent-file');\r\n```\r\n\r\n### Unit Test with Mocha\r\n\r\nFollowing example shows how to test a flow and a function with [Mocha](http://visionmedia.github.com/mocha/).\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\nvar as = require('as').as;\r\nvar fs = require('fs');\r\n\r\nvar concatFiles = flow(\r\n  function (file1, file2) {\r\n    fs.readFile(file1, 'utf8', this.async(as(1)));\r\n    fs.readFile(file2, 'utf8', this.async(as(1)));\r\n  },\r\n  function (data1, data2) {\r\n    this.next(data1 + data2);\r\n  }\r\n);\r\n\r\nfunction read(file) {\r\n  fs.readFile(file, 'utf8', this.async(as(1)));\r\n}\r\n\r\nvar assert = require('assert');\r\n\r\ndescribe('flow `concatFiles`', function () {\r\n  it('can be tested', function (done) {\r\n    flow(\r\n      concatFiles,\r\n      function (data) {\r\n        if (this.err) throw this.err;\r\n        assert.strictEqual(data, 'FILE1FILE2');\r\n        done();\r\n      }\r\n    )('file1', 'file2');\r\n  });\r\n});\r\n\r\ndescribe('function `read`', function () {\r\n  it('can be tested', function (done) {\r\n    flow(\r\n      read,\r\n      function (data) {\r\n        if (this.err) throw this.err;\r\n        assert.strictEqual(data, 'FILE1');\r\n        done();\r\n      }\r\n    )('file1');\r\n  });\r\n});\r\n```\r\n\r\n## Debugging\r\n\r\nUse `NODE_DEBUG=nue`. \r\n\r\n### Example\r\n\r\n> hoge.js\r\n\r\n```js\r\nvar flow = require('nue').flow;\r\n\r\nflow('hoge')(\r\n  function add(x, y) {\r\n    this.next(x + y);\r\n  },\r\n  function done(result) {\r\n    if (this.err) throw this.err;\r\n    console.log(result);\r\n  }\r\n)(10, 20);\r\n```\r\n\r\n> Run and Output\r\n\r\n```sh\r\n$ NODE_DEBUG=nue node hoge.js\r\nNUE: begin TOP_LEVEL_FLOW. flow: hoge(0), calledAt: /private/tmp/hoge.js:11:1, args: [ 10, 20 ]\r\nNUE: begin STEP. flow: hoge(0), step: add(0), args: [ 10, 20 ]\r\nNUE: begin STEP. flow: hoge(0), step: done(1), args: [ 30 ]\r\n30\r\n```",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/nakamura-to/nue/issues"
  },
  "_id": "nue@0.7.0-dev",
  "dist": {
    "shasum": "ba08c2b60f2c53d64aa6d04af086456fab94ab76"
  },
  "_from": "nue@0.7.0dev",
  "_resolved": "http://registry.npmjs.org/nue/-/nue-0.7.0dev.tgz"
}
